---
// src/components/ChatApp.astro
export interface Props {
    socketUrl?: string;
}

const { socketUrl = "http://localhost:9001" } = Astro.props;
---

<div id="chatApp" class="min-h-screen bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900">

        <!-- Chat Container -->
        <div id="chatContainer" class="min-h-screen flex flex-col">
            <!-- Header dinámico -->
            <header id="chatHeader" class="bg-white/10 backdrop-blur-md border-b border-white/20">
                <div class="container mx-auto px-6 py-4">
                    <h1 id="headerTitle" class="text-2xl font-bold text-white text-center">
                        Chat de Señalización
                    </h1>
                </div>
            </header>

            <!-- Status Bar -->
            <div id="statusBar" class="bg-yellow-500/20 border-b border-yellow-500/30 px-6 py-2 hidden">
                <p id="statusText" class="text-yellow-200 text-sm text-center"></p>
            </div>

            <!-- Main Content -->
            <main id="mainContent" class="flex-1 flex flex-col p-6">
                <!-- Chat Messages -->
                <div id="chatWindow" class="flex-1 bg-white/5 backdrop-blur-sm rounded-2xl border border-white/10 mb-4 hidden">
                    <div id="chatMessages" class="flex-1 p-6 overflow-y-auto space-y-3 max-h-96"></div>
                </div>

                <!-- Message Form -->
                <form id="messageForm" class="hidden">
                    <div class="flex gap-3">
                        <input 
                            type="text" 
                            id="messageInput" 
                            placeholder="Escribe un mensaje..."
                            class="flex-1 px-4 py-3 bg-white/10 border border-white/30 rounded-xl text-white placeholder-white/60 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-transparent transition-all duration-200"
                            disabled
                        />
                        <button 
                            type="submit" 
                            id="sendButton"
                            class="px-6 py-3 bg-purple-600 hover:bg-purple-700 disabled:bg-gray-600 disabled:cursor-not-allowed text-white font-semibold rounded-xl transition-all duration-200 transform hover:scale-105"
                            disabled
                        >
                            Enviar
                        </button>
                    </div>
                </form>

                <!-- Loading State -->
                <div id="loadingState" class="flex-1 flex items-center justify-center">
                    <div class="text-center">
                        <div class="inline-block animate-spin rounded-full h-12 w-12 border-b-2 border-white mb-4"></div>
                        <p class="text-white/80">Conectando...</p>
                    </div>
                </div>
            </main>
        </div>

</div>

<script define:vars={{ socketUrl }}>
    // Tipos TypeScript (simulados con JSDoc en el script)
    
    /**
     * @typedef {'loading' | 'waiting' | 'chatting'} ViewType
     */

    /**
     * @typedef {Object} Message
     * @property {string} text
     * @property {'mine' | 'theirs' | 'system'} type
     */

    /**
     * @typedef {Object} AppState
     * @property {ViewType} view
     * @property {any} socket
     * @property {string} myId
     * @property {string} roomId
     * @property {string} peerId
     * @property {Message[]} messages
     */
    const params = new URLSearchParams(window.location.search);
    const userId = params.get('userId');
    const roomId = params.get('roomId');

    class ChatApp {
        constructor() {
            /** @type {AppState} */
            this.state = {
                // CAMBIO 1: El estado inicial debe ser 'loading' para que la UI se muestre correctamente.
                view: 'loading',
                socket: null,
                myId: userId || '',
                roomId: roomId || '',
                peerId: '',
                messages: []
            };
            
            this.elements = {
                chatContainer: document.getElementById('chatContainer'),
                headerTitle: document.getElementById('headerTitle'),
                statusBar: document.getElementById('statusBar'),
                statusText: document.getElementById('statusText'),
                chatWindow: document.getElementById('chatWindow'),
                chatMessages: document.getElementById('chatMessages'),
                messageForm: document.getElementById('messageForm'),
                messageInput: document.getElementById('messageInput'),
                sendButton: document.getElementById('sendButton'),
                loadingState: document.getElementById('loadingState')
            };
        }

        init() {
            if (!this.state.myId || !this.state.roomId) {
                // Si faltan parámetros, podemos mostrar un error.
                if (this.elements.loadingState) {
                    this.elements.loadingState.innerHTML = `
                        <div class="text-center text-red-400">
                            <h2 class="text-xl font-bold mb-2">Error de Parámetros</h2>
                            <p>Falta 'userId' o 'roomId' en la URL.</p>
                            <p>Por favor, vuelve al lobby para iniciar.</p>
                        </div>
                    `;
                }
                return;
            }
            
            // CAMBIO 2: Llama a render() al inicio para sincronizar la UI con el estado inicial.
            this.render(); 
            this.setupEventListeners();
            this.connect();
        }

        setupEventListeners() {
            if (this.elements.messageForm) {
                this.elements.messageForm.addEventListener('submit', (e) => {
                    e.preventDefault();
                    this.sendMessage();
                });
            }
        }

        /**
         * @param {Partial<AppState>} newState 
         */
        setState(newState) {
            Object.assign(this.state, newState);
            this.render();
        }

        render() {
            // Update header
            if (this.elements.headerTitle) {
                this.elements.headerTitle.textContent = 
                    this.state.view === 'waiting' || this.state.view === 'chatting' 
                        ? `Sala: ${this.state.roomId}` 
                        : 'Chat de Señalización';
            }

            // Update status bar
            if (this.elements.statusBar && this.elements.statusText) {
                if (this.state.view === 'waiting' || this.state.view === 'chatting') {
                    this.elements.statusBar.classList.remove('hidden');
                    if (this.state.peerId) {
                        this.elements.statusText.innerHTML = `Chateando con <strong>${this.state.peerId}</strong>`;
                        this.elements.statusBar.className = 'bg-green-500/20 border-b border-green-500/30 px-6 py-2';
                        this.elements.statusText.className = 'text-green-200 text-sm text-center';
                    } else {
                        this.elements.statusText.textContent = 'Esperando a otro usuario...';
                        this.elements.statusBar.className = 'bg-yellow-500/20 border-b border-yellow-500/30 px-6 py-2';
                        this.elements.statusText.className = 'text-yellow-200 text-sm text-center';
                    }
                } else {
                    this.elements.statusBar.classList.add('hidden');
                }
            }

            // Show/hide elements based on state
            // Esta lógica ahora funciona porque 'view' empieza en 'loading'
            if (this.state.view) {
                this.elements.loadingState?.classList.add('hidden');
                this.elements.chatWindow?.classList.remove('hidden');
                this.elements.messageForm?.classList.remove('hidden');
                
                const isConnected = !!this.state.peerId;
                if (this.elements.messageInput) {
                    this.elements.messageInput.disabled = !isConnected;
                }
                if (this.elements.sendButton) {
                    this.elements.sendButton.disabled = !isConnected;
                }
            } else { // Esto se ejecuta para el estado 'loading'
                this.elements.loadingState?.classList.remove('hidden');
                this.elements.chatWindow?.classList.add('hidden');
                this.elements.messageForm?.classList.add('hidden');
            }

            this.renderMessages();
            this.scrollToBottom();
        }

        renderMessages() {
            if (!this.elements.chatMessages) return;

            this.elements.chatMessages.innerHTML = this.state.messages
                .map(msg => this.createMessageElement(msg))
                .join('');
        }

        /**
         * @param {Message} message 
         * @returns {string}
         */
        createMessageElement(message) {
            const baseClasses = 'px-4 py-2 rounded-lg max-w-xs break-words';
            
            switch (message.type) {
                case 'mine':
                    return `
                        <div class="flex justify-end">
                            <div class="${baseClasses} bg-purple-600 text-white ml-auto">
                                ${message.text}
                            </div>
                        </div>
                    `;
                case 'theirs':
                    return `
                        <div class="flex justify-start">
                            <div class="${baseClasses} bg-white/20 text-white mr-auto">
                                ${message.text}
                            </div>
                        </div>
                    `;
                case 'system':
                    return `
                        <div class="flex justify-center">
                            <div class="px-3 py-1 bg-white/10 text-white/80 text-sm rounded-full text-center">
                                ${message.text}
                            </div>
                        </div>
                    `;
                default:
                    return '';
            }
        }

        async connect() {
            try {
                // Importar Socket.IO dinámicamente                
                this.state.socket = io(socketUrl, {
                    query: { 
                        userid: this.state.myId, 
                        sessionid: this.state.roomId 
                    }
                });

                this.setupSocketListeners();

                this.state.socket.on('connect', () => {
                    this.addMessage(`Conectado al servidor como <strong>${this.state.myId}</strong>.`, 'system');

                    // Lógica para unirse o crear la sala
                    this.state.socket.emit('check-presence', this.state.roomId, (isPresent) => {
                        const isInitiator = !isPresent;
                        const action = isInitiator ? 'open-room' : 'join-room';
                        const params = { sessionid: this.state.roomId };

                        this.state.socket.emit(action, params, (success, error) => {
                            if (success) {
                                // Aquí cambiamos la vista a 'waiting', lo que oculta el spinner
                                this.setState({ view: 'waiting' });
                                this.addMessage(
                                    isInitiator ? 'Sala creada. Esperando...' : 'Unido a la sala...', 
                                    'system'
                                );
                                
                                if (!isInitiator) {
                                    this.state.socket.emit('RTCMultiConnection-Message', {
                                        remoteUserId: this.state.roomId,
                                        message: { 
                                            newParticipationRequest: true, 
                                            sender: this.state.myId 
                                        }
                                    });
                                }
                            } else {
                                alert(`Error al unirse a la sala: ${error}`);
                                // Opcional: mostrar error en la UI en lugar de un alert
                                this.addMessage(`Error: ${error}`, 'system');
                            }
                        });
                    });
                });

            } catch (error) {
                console.error('Error al cargar o conectar con Socket.IO:', error);
                this.addMessage('Error de conexión. Verifica la URL del socket y que el servidor esté en línea.', 'system');
                // Dejamos el estado en 'loading' para que no oculte el mensaje de error
            }
        }

        setupSocketListeners() {
            const socket = this.state.socket;

            socket.on('user-connected', (peerId) => {
                this.setState({ peerId: peerId, view: 'chatting' });
                this.addMessage(`¡Usuario <strong>${peerId}</strong> se ha conectado!`, 'system');
            });

            socket.on('user-disconnected', (peerId) => {
                if (this.state.peerId === peerId) {
                    this.addMessage(`Usuario <strong>${peerId}</strong> se ha desconectado.`, 'system');
                    this.setState({ peerId: '', view: 'waiting' });
                }
            });

            socket.on('RTCMultiConnection-Message', (message) => {
                if (message.sender === this.state.peerId && message.message?.type === 'text-message') {
                    this.addMessage(this.escapeHTML(message.message.data), 'theirs');
                }
            });

            socket.on('disconnect', () => {
                this.addMessage('Desconectado del servidor.', 'system');
                this.setState({ view: 'waiting', peerId: '' });
            });
        }

        sendMessage() {
            if (!this.elements.messageInput) return;
            
            const text = this.elements.messageInput.value.trim();

            if (!text || !this.state.peerId) return;

            const messagePayload = {
                sender: this.state.myId,
                remoteUserId: this.state.peerId,
                message: { type: 'text-message', data: text }
            };

            this.state.socket.emit('RTCMultiConnection-Message', messagePayload);
            this.addMessage(this.escapeHTML(text), 'mine');
            
            this.elements.messageInput.value = '';
            this.elements.messageInput.focus();
        }

        /**
         * @param {string} text 
         * @param {'mine' | 'theirs' | 'system'} type 
         */
        addMessage(text, type) {
            this.state.messages.push({ text, type });
            this.render();
        }

        scrollToBottom() {
            if (this.elements.chatMessages) {
                this.elements.chatMessages.scrollTop = this.elements.chatMessages.scrollHeight;
            }
        }

        /**
         * @param {string} str 
         * @returns {string}
         */
        escapeHTML(str) {
            const p = document.createElement('p');
            p.appendChild(document.createTextNode(str));
            return p.innerHTML;
        }
    }

    // Inicializar la aplicación cuando el DOM esté listo
    document.addEventListener('DOMContentLoaded', () => {
        if (userId && roomId) {
            const app = new ChatApp();
            app.init();
        } else {
             // Si no hay parámetros, inicializamos la app para que muestre el error
             const app = new ChatApp();
             app.init();
        }
    });
</script>